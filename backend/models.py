"""
Pydantic models for TaskLedger.
Defines structured schemas for meetings, action items, risk flags, and clarifications.
These models are used for:
1. API request/response validation
2. LLM structured outputs via PydanticAI
3. Database persistence (Phase 2)
"""
from pydantic import BaseModel, Field, field_validator
from typing import Optional, List
from datetime import datetime, date
from enum import Enum
from uuid import UUID, uuid4


# === ENUMS ===

class Priority(str, Enum):
    """Priority levels for action items."""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class RiskType(str, Enum):
    """Types of risks identified during validation."""
    VAGUE_DESCRIPTION = "vague_description"
    MISSING_OWNER = "missing_owner"
    MISSING_DEADLINE = "missing_deadline"
    UNCLEAR_DEPENDENCY = "unclear_dependency"
    SCOPE_TOO_BROAD = "scope_too_broad"
    CONFLICTING_ASSIGNMENT = "conflicting_assignment"


class ConfidenceLevel(str, Enum):
    """Confidence levels for action item extraction."""
    LOW = "low"          # 0-40%
    MEDIUM = "medium"    # 41-70%
    HIGH = "high"        # 71-100%


# === CORE MODELS ===

class RiskFlag(BaseModel):
    """
    Represents a risk identified during validation.
    Generated by the Validation Agent.
    """
    risk_type: RiskType = Field(..., description="Type of risk identified")
    description: str = Field(..., description="Detailed explanation of the risk")
    severity: Priority = Field(..., description="How critical is this risk")
    suggested_clarification: Optional[str] = Field(
        None,
        description="Question to ask user to resolve this risk"
    )

    model_config = {
        "json_schema_extra": {
            "examples": [{
                "risk_type": "missing_owner",
                "description": "No owner explicitly assigned for this task",
                "severity": "high",
                "suggested_clarification": "Who should be responsible for implementing the new dashboard?"
            }]
        }
    }


class ActionItem(BaseModel):
    """
    Represents a single action item extracted from meeting notes.
    Core entity in the system.
    """
    id: str = Field(default_factory=lambda: str(uuid4()), description="Unique identifier")
    description: str = Field(..., min_length=5, description="What needs to be done")
    owner: Optional[str] = Field(None, description="Person responsible (only if explicit)")
    deadline: Optional[date] = Field(None, description="Due date (only if explicit)")
    priority: Priority = Field(default=Priority.MEDIUM, description="Importance level")
    confidence: ConfidenceLevel = Field(..., description="How confident are we in this extraction")
    confidence_score: float = Field(..., ge=0.0, le=1.0, description="Numeric confidence (0-1)")
    risk_flags: List[RiskFlag] = Field(default_factory=list, description="Issues identified")
    dependencies: List[str] = Field(default_factory=list, description="Other action item IDs this depends on")
    context: Optional[str] = Field(None, description="Additional context from meeting")
    
    @field_validator("description")
    @classmethod
    def description_not_empty(cls, v: str) -> str:
        """Ensure description is meaningful."""
        if not v or v.strip() == "":
            raise ValueError("Description cannot be empty")
        return v.strip()
    
    @property
    def needs_clarification(self) -> bool:
        """Check if this action item has any risk flags."""
        return len(self.risk_flags) > 0
    
    @property
    def is_complete(self) -> bool:
        """Check if action item has owner and deadline."""
        return self.owner is not None and self.deadline is not None

    model_config = {
        "json_schema_extra": {
            "examples": [{
                "id": "550e8400-e29b-41d4-a716-446655440000",
                "description": "Implement user authentication with OAuth2",
                "owner": "Alice",
                "deadline": "2026-01-30",
                "priority": "high",
                "confidence": "high",
                "confidence_score": 0.92,
                "risk_flags": [],
                "dependencies": [],
                "context": "Discussed in security review section"
            }]
        }
    }


# === MEETING MODELS ===

class MeetingInput(BaseModel):
    """
    Input model for processing new meeting notes.
    Sent by frontend to POST /meetings/process
    """
    meeting_text: str = Field(..., min_length=20, description="Raw meeting notes or transcript")
    participants: List[str] = Field(default_factory=list, description="List of participant names")
    meeting_title: Optional[str] = Field(None, description="Optional meeting title")
    meeting_date: Optional[date] = Field(default_factory=date.today, description="When meeting occurred")
    
    @field_validator("meeting_text")
    @classmethod
    def meeting_text_not_empty(cls, v: str) -> str:
        """Ensure meeting text is substantial."""
        if not v or len(v.strip()) < 20:
            raise ValueError("Meeting text must be at least 20 characters")
        return v.strip()
    
    @field_validator("participants")
    @classmethod
    def clean_participants(cls, v: List[str]) -> List[str]:
        """Remove empty strings and duplicates."""
        return list(set([p.strip() for p in v if p.strip()]))

    model_config = {
        "json_schema_extra": {
            "examples": [{
                "meeting_text": "Team discussed Q1 roadmap. Alice will implement auth by Jan 30. Bob needs to review API docs. Charlie raised concerns about scalability.",
                "participants": ["Alice", "Bob", "Charlie"],
                "meeting_title": "Q1 Planning",
                "meeting_date": "2026-01-19"
            }]
        }
    }


class Meeting(BaseModel):
    """
    Complete meeting record with processed action items.
    Returned after agent pipeline completes.
    """
    id: str = Field(default_factory=lambda: str(uuid4()), description="Unique identifier")
    meeting_text: str = Field(..., description="Original meeting notes")
    participants: List[str] = Field(default_factory=list)
    meeting_title: Optional[str] = None
    meeting_date: date = Field(default_factory=date.today)
    action_items: List[ActionItem] = Field(default_factory=list, description="Extracted action items")
    processed_at: datetime = Field(default_factory=datetime.now, description="When processing completed")
    total_confidence: float = Field(..., ge=0.0, le=1.0, description="Overall confidence score")
    
    @property
    def items_needing_clarification(self) -> List[ActionItem]:
        """Get action items with risk flags."""
        return [item for item in self.action_items if item.needs_clarification]
    
    @property
    def total_risk_count(self) -> int:
        """Total number of risk flags across all items."""
        return sum(len(item.risk_flags) for item in self.action_items)

    model_config = {
        "json_schema_extra": {
            "examples": [{
                "id": "660e8400-e29b-41d4-a716-446655440000",
                "meeting_text": "Team discussed Q1 roadmap...",
                "participants": ["Alice", "Bob", "Charlie"],
                "meeting_title": "Q1 Planning",
                "meeting_date": "2026-01-19",
                "action_items": [],
                "processed_at": "2026-01-19T10:30:00",
                "total_confidence": 0.85
            }]
        }
    }


# === CLARIFICATION MODELS ===

class ClarificationQuestion(BaseModel):
    """
    A single clarification question for an action item.
    Generated by Refinement Agent.
    """
    question_id: int = Field(..., description="Unique ID for this question")
    question: str = Field(..., description="Question to ask the user")
    field: str = Field(..., description="Which field needs clarification (owner, deadline, description)")
    action_item_id: str = Field(..., description="ID of the action item being clarified")
    priority: str = Field(..., description="Priority of this question (critical, high, medium, low)")


class ClarificationQuestionsOutput(BaseModel):
    """
    Output from Refinement Agent containing generated questions.
    Used for LLM structured output.
    """
    questions: List[ClarificationQuestion] = Field(
        default_factory=list,
        description="List of clarification questions prioritized by importance"
    )


class UserClarificationAnswers(BaseModel):
    """
    Internal model for parsed user responses to clarification questions.
    Not used for API - only for agent processing.
    """
    answers: List[dict] = Field(
        default_factory=list,
        description="List of {question_id, action_item_id, field, answer}"
    )
    timestamp: datetime = Field(default_factory=datetime.now)


class ClarificationRequest(BaseModel):
    """
    Request model for clarifying action items.
    POST /action-items/{id}/clarify
    """
    action_item_id: str = Field(..., description="ID of action item to clarify")
    clarifications: dict[str, str] = Field(
        ...,
        description="Field-value pairs with clarification answers",
        examples=[{"owner": "Alice", "deadline": "2026-01-30"}]
    )
    additional_context: Optional[str] = Field(None, description="Any extra information provided")

    model_config = {
        "json_schema_extra": {
            "examples": [{
                "action_item_id": "550e8400-e29b-41d4-a716-446655440000",
                "clarifications": {
                    "owner": "Alice",
                    "deadline": "2026-01-30"
                },
                "additional_context": "Alice confirmed she'll handle this"
            }]
        }
    }


class ClarificationResponse(BaseModel):
    """
    Response after processing clarification.
    Returns updated action item.
    """
    action_item: ActionItem = Field(..., description="Updated action item")
    previous_risk_count: int = Field(..., description="Risk flags before clarification")
    current_risk_count: int = Field(..., description="Risk flags after clarification")
    resolved_risks: List[RiskType] = Field(default_factory=list, description="Risks that were resolved")

    model_config = {
        "json_schema_extra": {
            "examples": [{
                "action_item": {},
                "previous_risk_count": 2,
                "current_risk_count": 0,
                "resolved_risks": ["missing_owner", "missing_deadline"]
            }]
        }
    }


# === AGENT OUTPUT MODELS ===
# These are specifically for LLM structured outputs

class ExtractionOutput(BaseModel):
    """
    Output from Extraction Agent.
    Raw action items without owner/deadline attribution.
    """
    raw_actions: List[str] = Field(..., description="List of action descriptions extracted from meeting")

    model_config = {
        "json_schema_extra": {
            "examples": [{
                "raw_actions": [
                    "Implement user authentication",
                    "Review API documentation",
                    "Address scalability concerns"
                ]
            }]
        }
    }


class AttributionOutput(BaseModel):
    """
    Output from Attribution Agent.
    Adds owner and deadline only if explicit.
    """
    action_items: List[ActionItem] = Field(..., description="Action items with attribution")


class ValidationOutput(BaseModel):
    """
    Output from Validation Agent.
    Adds risk flags, confidence scores, and priority.
    """
    validated_items: List[ActionItem] = Field(..., description="Action items with validation results")
    overall_confidence: float = Field(..., ge=0.0, le=1.0, description="Overall confidence in extraction")


# === ERROR MODELS ===

class ErrorResponse(BaseModel):
    """Standard error response format."""
    error: str = Field(..., description="Error type")
    message: str = Field(..., description="Human-readable error message")
    details: Optional[dict] = Field(None, description="Additional error context")

    model_config = {
        "json_schema_extra": {
            "examples": [{
                "error": "ValidationError",
                "message": "Meeting text is too short",
                "details": {"min_length": 20, "provided": 5}
            }]
        }
    }
